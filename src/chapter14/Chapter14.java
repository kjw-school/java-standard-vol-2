package chapter14;

/**
 * <h1>1. 람다식(Lambda expression)</h1>
 */
public class Chapter14 {

	/**
	 * <p>
	 *     자바가 1996년에 처음 등장한 이후로 두 번의 큰 변화가 있었는데, 한번은 JDK1.5부터 추가된 지네릭스(generics)의 등장이고,<br>
	 *     또 한 번은 JDK1.8부터 추가된 람다식(lambda expression)의 등장이다.<br>
	 *     특히 람다식의 도입으로 인해, 이제 자바는 객체지향언어인 동시에 함수형 언어가 되었다.
	 * </p>
	 */
	class Memo01{}

	/**
	 * <p>
	 *     <h5>1.1 람다식이란?</h5><br>
	 *     람다식(Lambda expression)은 간단히 말해서 메서드를 하나의 '식(expression)'으로 표현한 것이다.<br>
	 *     람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.<br>
	 *     메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 '익명 함수(anonymous function)'이라고도 한다.<br>
	 *     <code>
	 *         int[] arr = new int[5];<br>
	 *         Arrays.setAll(arr, <b>(i) -> (int)(Math.random()*5)+1)</b>;
	 *     </code>
	 *     <br>
	 *     람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고, 메서드의 결과로 반환될 수도 있다. 람다식으로 인해 메서드를 변수처럼 다루는 것이 가능해진 것이다.<br>
	 *     ※메서드와 함수의 차이<br>
	 *     - 객체지향개념에서는 함수(function)대신 객체의 행위나 동작을 의미하는 메서드(method)라는 용어를 사용한다.<br>
	 *       메서드는 함수와 같은 의미이지만, 특정 클래스에 반드시 속해야 한다는 제약이 있기 때문에 기존의 함수와 같은 의미의 다른 용어를 선택해서 사용한 것이다.<br>
	 *       그러나 이제 다시 람다식을 통해 메서드가 하나의 독립적인 기능을 하기 때문에 함수라는 용어를 사용하게 되었다.<br>
	 * </p>
	 */
	class Memo02{}

	/**
	 * <p>
	 *     <h5>1.2 람다식 작성하기</h5><br>
	 *		람다식은 '익명 함수'답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 '->'를 추가한다.<br>
	 *		<pre>
	 *반환타입 메서드이름(매개변수 선언) {
	 *  문장들
	 *}
	 *↓
	 *(매개변수 선언) -> {
	 *  문장들
	 *}
	 *		</pre>
	 *		<br>
	 *		반환값이 있는 메서드의 경우, return문 대신 '식(expression)'으로 대신할 수 있다.<br>
	 *		식의 연산결과가 자동적으로 반환값이 된다. 이때는 '문장(statement)'이 아닌 '식'이므로 끝에 ';'을 붙이지 않는다.<br>
	 *		(int a, int b) -> {return <b>a > b ? a : b;</b>} -> (int a, int b) -> <b>a > b ? a : b</b>
	 *		<br>
	 *		람다식에 선언된 매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다.<br>
	 *		람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.
	 *		(<b>int</b> a, <b>int</b> b) -> a > b ? a: b -> (a, b) -> a > b ? a : b
	 *		<br>
	 *		<small>※'(int a,b) -> a > b ? a : b' 와 같이 두 매개변수 중 어느 하나의 타입만 생략하는 것은 허용되지 않는다.</small>
	 *		<br>
	 *		선언된 매개변수가 하나뿐인 경우에는 괄호()를 생략할 수 있다. 단, 매개변수의 타입이 있으면 괄호()를 생략할 수 없다.<br>
	 *		마찬가지로 괄호{} 안의 문장이 하나일 때는 괄호{}를 생략할 수 있다. 이 때 문장의 끝에 ';'을 붙이지 않아야 한다는 것에 주의하자.
	 *		<br>
	 *		그러나 괄호{}안의 문장이 return문일 경우 괄호{}를 생략할 수 없다.
	 * </p>
	 */
	class Memo03{}

	/**
	 * <h5>1.3 함수형 인터페이스(Functional Interface)</h5><br>
	 * 사실 람다식은 익명 클래스의 객체와 동등하다.<br>
	 * <code>타입 f = (int a, int b) -> a > b ? a: b; // 참조변수의 타입을 뭘로 해야 할까?</code>
	 * <br>
	 * 참조변수 f의 타입은 어떤 것이어야 할까? 참조형이니까 클래스 또는 인터페이스가 가능하다. 그리고 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다.<br>
	 * 그래야만 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.
	 * <br>
	 * 익명 객체를 람다식으로 대체가 가능한 이유는, 람다식도 실제로 익명 객체이고, 해당 인터페이스를 구현한 익명 객체의 메서드와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 떄문이다.
	 * <br>
	 * 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다.
	 * <br>
	 * 그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 '함수형 인터페이스(functional interface)'라고 부르기로 했다.
	 * <br>
	 * 함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 그래야 람다식돠 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.<br>
	 * 반면에 static메서드와 default메서드의 개수에는 제약이 없다.<br>
	 * <small>※'@FunctionalInterface'를 붙이면, 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해주므로, 꼭 붙이도록 하자.</small>
	 * <br>
	 * <b>함수형 인터페이스 타입의 매개변수와 반환타입</b>
	 * <br>
	 * 메서드의 반환타입이 함수형 인터페이스타입이라면, 이 함수형 인터페이스의 추상메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다.<br>
	 * 람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 즉, 변수처럼 메서드를 주고받는 것이 가능해진 것이다.<br>
	 * 사실상 메서드가 아니라 객체를 주고받는 것이라 근본적으로 달라진 것은 아무것도 없다.
	 */
	class Memo04{}

	@FunctionalInterface
	interface MyFunction {
		void run(); // public abstract void run();
	}

	static class LambdaEx1 {

	}

}
