package chapter11;

/**
 * <h1>1.6 Arrays</h1><br>
 * Arrays클래스에는 배열을 다루는데 유용한 메서드가 정의되어 있다.<br>
 * <small>※ Arrays에 정의된 메서드는 모두 static메서드이다.</small>
 */
public class Chapter11_1_6 {

	/**
	 * <h5>배열의 복사 - copyOf(), copyOfRange()</h5><br>
	 * copyOf()는 배열 전체를, copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다. copyOfRange()에 지정된 범위의 끝은 포함되지 않는다.
	 */
	class Memo1 {

	}

	/**
	 * <h5>배열 채우기 - fill(), setAll()</h5><br>
	 * fill()은 배열의 모든 요소를 지정된 값으로 채운다. setAll()은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.<br>
	 * 이 메서드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야 한다.
	 */
	class Memo2 {

	}

	/**
	 * <h5>배열의 정렬과 검색 - sort(), binarySearch()</h5><br>
	 * sort()는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 binarySearch()를 사용한다. binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻는다.<br>
	 * 배열의 첫 번째 요소부터 순서대로 하나씩 검색하는 것을 '순차 검색(linear search)'이라고 하는데, 이 검색 방법은 배열이 정렬되어 있을 필요는 없지만 배열의 요소를 하나씩 비교하기 때문에 시간이 많이 걸린다.<br>
	 * 이진 검색(binary search)은 배열의 검색할 범위를 반복적으로 절반씩 줄여나가면서 검색하기 때문에 검색속도가 상당히 빠르다. 배열의 길이가 10배가 늘어나도 검색 횟수는 3~4회 밖에 늘어나지 않으므로 큰 배열의 검색에 유리하다. 배열이 정렬이 되어 있는 경우에만 사용할 수 있다는 단점이 있다.
	 */
	class Memo3 {

	}

	/**
	 * <h5>배열의 비교와 출력 - equals(), toString()</h5><br>
	 */
	class Memo4 {

	}

}
